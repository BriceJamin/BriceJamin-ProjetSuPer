1. [Résolu] Pleins de fenêtres s'ouvrent, et le PC ne répond plus.
   Cause :
      Les lecteurs tentent de se connecter tant qu'ils n'y parviennent pas.
      Un lecteur dont l'ip n'est pas présente dans la bdd est considéré comme un intrus.
      Lorsqu'un intrus est détecté sa connexion est fermée et une fenêtre s'ouvre pour le signaler.
      Une fois déconnecté le lecteur retente de se connecter, ce qui entraine une boucle infinie de connexion avec ouverture de fenêtre et déconnexion.

   Solutions envisagées :
      1. Fermer les fenêtres à la déconnexion pour libérer les ressources.
         Ne résoud pas le problème du flood de demande de connexion.
         Solution abandonnée.
      2. [Adopté] Ne pas fermer la connexion pour éviter d'avoir à traiter une nouvelle requête et éviter la boucle infinie.


2. [Résolu] Erreur qui apparait lors du flood de demande de connexion d'ip interdites :
      QSqlDatabasePrivate::addDatabase: duplicate connection name '139675828455168', old connection removed.
   Cause : Lorsqu'un intrus est détecté dans ClientConnection::filter(), la méthode ne se termine pas proprement.

   Solutions envisagées :
      1. [Adopté] Terminer la méthode ClientConnection::filter() proprement en :
         - Appelant QSqlDatabase::removeDatabase() si QSqlDatabase::addDatabase() a été appelé.
         - Appelant QSqlDatabase::close() si QSqlDatabase::open() a été appelé.
         - Appelant QSqlQuery::finish() si QSqlQuery::exec() a été appelé.


3. [Résolu] Erreur qui apparait à la fermeture du programme, après avoir subi un flood de demande de connexions d'ip interdites :
      Error in my_thread_global_end(): 13 threads didn't exit
   Cause : Serait la même que pour le bug n°2.

   Solutions envisagées :
      1. [Adopté]  Résoudre le bug n°2 et voir si celui-ci disparait.
         En cour  de résolution du bug n°2, celui ci a disparu.


4. [Résolu] Un lecteur que l'on débranche physiquement n'est pas détecté.
   Tous les signaux de QTcpSocket ont été implémenté, ça ne se détecte donc pas par cette classe.
   Il n'y a plus que la classe QTcpServer concernée par ce genre d'évènement qui serait susceptible de le détecter.

   Solutions envisagées :
      1. [Rejeté] Réimplémenter tous les signaux de la classe QTcpServer afin de voir si l'un d'entre eux détecte cette déconnexion.
         Déjà effectué, il n'y en a qu'un : incommingConnection().
      2. [Adopté] Utiliser l'option TCP keep alive qui envoit régulièrement un paquet pour maintenanir la connexion active, et permettrai cette détection.
         Cette option est activable dans QT via la classe mère de QTcpSocket :
	    void QAbstractSocket::setSocketOption ( QAbstractSocket::SocketOption option, const QVariant & value )
	 Où QAbstractSocket::SocketOption est une enum contenant :
            QAbstractSocket::KeepAliveOption : Set this to 1 to enable the SO_KEEPALIVE socket option
         Après vérification, l'option est bien désactivée.
         Après activation, un débranchement du lecteur ne déclenche aucun signal après quelques secondes.
      3. [Adopté] Consulter la configuration du TCP KeepAlive directement sur l'OS.
         Sur Debian, 3 fichiers permettent de configurer cela :
	    - /proc/sys/net/ipv4/tcp_keepalive_time
	       Durée d'attente avant d'envoyer le premier paquet keepalive : 7200 secondes
	    - /proc/sys/net/ipv4/tcp_keepalive_intvl
	       Durée d'attente avant un renvoi du paquet keepalive : 75 secondes
	    - /proc/sys/net/ipv4/tcp_keepalive_probes
	       Nombre de renvoi sans réponse avant de considérer la cible comme déconnectée : 9
	 Cette configuration n'est pas adaptée, il faut attendre 7200 secondes avant de commencer à vérifier si le lecteurs est connecté ou non.
     4. [Adopté] Modifier la configuration, avec :
           - Démarrage du keepalive immédiat (0 seconde d'attente).
	   - Renvoyer un paquet keepalive toutes les 5 secondes.
	   - Si pas de réponse au bout de 3 renvois, considérer que la connexion est perdue.
	Avec cette config il serait théoriquement possible de détecter un lecteur débranché au bout de :
	   - 3 x 5 >= 15 secondes dans le meilleur des cas (premier envoi juste après le débranchement du lecteur)
	   - 4 x 5 <= 20 secondes dans le pire des cas (premier envoi juste avant le débranchement du lecteur).
        Après une configuration avec ces valeurs via la commande :
	   sysctl -w net.ipv4.tcp_keepalive_time=0 net.ipv4.tcp_keepalive_intvl=5 net.ipv4.tcp_keepalive_probes=3
	Et un test avec activation logicielle du keepalive (voir la solution proposée n°3), la déconnexion du lecteur est bien détectée.

5. Un lecteur inconnu dont la connexion est établie mais dont la communication est ignorée a certainement un buffer qui grossit, vu que readyRead est déclenché. Ce qui peut poser un problème de mémoire.

   Solutions envisagées :
      1. [Adopté] Vider régulièrement le buffer pour l'empêcher de grossir.


6. La configuration TCP KeepAlive est perdue après un redémarrage.

   Solutions envisagées :
      1. Rendre cette permission permanente via les bons fichiers de configuration.
