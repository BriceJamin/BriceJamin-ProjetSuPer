Une personne est caractérisée par un nom et un prénom.
Elle peut appartenir à une société.
Elle peut avoir une durée d'intervention qui commence et se termine à des dates précises.
Elle peut être représentée par une photo.

Ce qui peut se représenter dans une base de données MySQL par les champs suivants :
- nom, de type texte, donc un VARCHAR de taille 50 devrait être suffisant
- prenom, idem
- societe, idem
- dateDebut, qui représente une date composée d'un jour, d'un mois et d'une année, donc un DATE
- dateFin, idem

Afin de garantir l'absence de doublons dans la base de donnée, un tuple représentant une personne doit être unique.
Il parait donc judicieux d'interdire les personnes ayant le même nom et le même prénom.
C'est pour cela que la table personne doit avoir pour clef primaire le couple de champs nom et prenom.
Et pour référencer ses tuples dans d'autre tables, il faut un champs de valeur unique représentant un seul tuple.
C'est pourquoi il faut lui ajouter un champs représentant un identifiant : num_pers.
C'est un nombre positif unique, donc il est de type INT UNSIGNED et a la contrainte UNIQUE.
Pour éviter d'avoir à réfléchir à la valeur qu'il faut lui donner, il est préférable de demander au SGBD de gérer sa numérotaion avec le mot clef AUTO_INCREMENT.

Pour assurer l'intégrité des dates, c'est à dire assurer que dateDebut se situe dans le temps avant dateFin, il faut utiliser les contraintes CHECK.
Malheureusement MySQL ne les prend pas en compte.
Mais il existe une solution qui consiste à utiliser des Triggers, portions de codes exécutées lors de l'ajout ou de modification d'un tuple personne, et de vérifier si les champs sont valides.
S'il ne le sont pas, il suffit alors d'emmettre une erreur avec un message similaire à celui généré par la contrainte CHECK.

Exemple d'un trigger refusant l'insertion d'un tuple personne si les dates ne sont pas valides :
delimiter //
CREATE TRIGGER personne_before_insert BEFORE INSERT ON personne
FOR EACH ROW
BEGIN
        IF NEW.dateDebut >= NEW.dateFin THEN
		SIGNAL SQLSTATE '23000'
		   SET MESSAGE_TEXT = 'Error: check constraint (personne.dateDebut <= personne.dateFin) failed.';
	END IF;
END//
delimiter ;

Pour permettre à l'utilisateur de créer une nouvelle personne, il faut lui proposer des champs à remplir, pour récupérer leurs valeurs et les insérer dans la bdd.


Les dates de début et fin d'intrervention :
Comment sélectionner une date avec Qt ?
QDateEdit est une zone d'edition qui permet l'affichage d'une popup calendrier permettant de sélectionner la date si son attribut calendarPopup : bool est à true.
Le format de la date affichée par défaut est : JJ Mmm AAAA.

Comment récupérer la date saisie ?
Grâce à l'accesseur QDate date () const de QDateEdit.

La date saisie doit être insérée dans la Bdd, dans un champs de type DATE.
 Quelles sont les spécificitées du type DATE ?
 DATE est prévu pour stocker une date avec l'année, le mois, le jour.
 Il est au format AAAA-MM-JJ et l'intervalle de validité va de '1000-01-01' à '9999-12-31'.
 Les deux formats (saisi et celui de date) ne correspondent pas.
Comment  obtenir le bon format pour DATE à partir de avec Qt ?
 La date saisie récupérée est un QDate.
 QDate possède une méthode QString QDate::toString ( Qt::DateFormat format = Qt::TextDate ) const.
 DateFormat est un enum, il faut choisir Qt::ISODate pour obtenir "ISO 8601 extended format: either YYYY-MM-DD".

Il faudrait que par défaut la date d'aujourdhui soit sélectionnée pour dateDebut et dateFin.
 Comment obtenir la date d'aujourd'hui avec Qt ?
 Avec QDate QDate::currentDate () qui retourne la date courante du système.

Il faut interdire une date de fin située plus tôt dans le temps que dateDebut.
 Pour cela un test doit être effectué lors de la modification de chacun des champs : dateDebut <= dateFin.
 Si le test est négatif, autoriser la modif mais modifier l'autre champs de manière à ce qu'il ait la même valeur que l'autre.
 Comment comparer des dates en Qt ?
 La comparaison de QDate est possible grâce à a surcharge de l'opérateur bool QDate::operator<= ( const QDate & d ) const.
 Pour éviter à l'utilisateur un refus des modifications pour un tel test négatif, il faudrait que lors de l'édition d'une dateDebut > dateFin, dateFin prenne la valeur de dateDebut.
 Idem lors de l'édition d'une dateFin < dateDebut, dateDebut doit prendre la valeur de dateFin.
 Une contrainte sur les champs dateDebut et dateFin dans la Bdd pourrait être ajoutée pour garantir son intégrité.
 Mais la contrainte sur deux colonnes ne semble pas marcher...


